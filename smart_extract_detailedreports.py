#!/usr/bin/env python3
"""
Enhanced CSV Creation from Detailed Reports with Smart LLM Extraction
===================================================================

This script consolidates comprehensive knowledge from all 63 detailed mineral reports by:

1. Extracting italicized summaries from 9 key sections per report:
   - Bottleneck analysis
   - Volume data (Current Production, Demand 2030, Supply 2030)  
   - 5 Technology categories (Discovery, Extraction, Separation, Purification, Remediation)

2. Using Claude AI to intelligently resolve unit ambiguities (MT = metric tons vs million tons)
3. Converting all volume data to consistent tonnage with contextual analysis
4. Updating the original CSV with clean, accurate technology summaries and production data

The detailed reports contain comprehensive supply chain analysis generated by OpenAI 4o-mini 
and fact-checked by Claude Opus 4.1. This script distills that knowledge into a structured 
format for analysis and visualization.

Handles ambiguous units like MT (metric tons vs million tons) using context.
"""

import os
import re
import csv
import glob
import json
from pathlib import Path

# You'll need to install: pip install anthropic
try:
    import anthropic
    HAS_ANTHROPIC = True
except ImportError:
    print("Warning: anthropic package not installed. Install with: pip install anthropic")
    HAS_ANTHROPIC = False

def extract_italicized_summaries(markdown_content):
    """Extract italicized summaries from markdown content."""
    summaries = {}
    sections = re.split(r'\n## ', markdown_content)
    
    for section in sections:
        lines = section.split('\n')
        if not lines:
            continue
            
        header = lines[0].strip('#').strip()
        
        # Look for italicized summary in next few lines
        for line in lines[1:6]:
            line = line.strip()
            match = re.match(r'^\*Summary:\s*(.+)\*$', line)
            if match:
                summaries[header] = match.group(1)
                break
    
    return summaries

def smart_extract_volume_with_llm(text, metal_name, section_type, client):
    """
    Use Claude to intelligently extract volume numbers from text.
    Handles MT ambiguity and context-dependent units.
    """
    if not text or not HAS_ANTHROPIC:
        return extract_basic_volume(text)
    
    prompt = f"""
Extract the volume/tonnage number from this text and convert it to tons (metric tons).

Context:
- Metal: {metal_name}
- Section: {section_type}
- Text: "{text}"

Rules:
1. If "Mt" appears, use context to determine if it means:
   - "metric tons" (same as tons) - for small/rare metals
   - "million tons" (multiply by 1,000,000) - for bulk commodities like aluminum, copper
   
2. Other units:
   - "kt" = thousand tons (multiply by 1,000)
   - "t" = tons (no conversion)
   - Plain numbers = assume tons

3. For ranges like "40-60", return the midpoint (50)
4. For "~10.5", return 10.5
5. Return ONLY the final number in tons, no text

Examples:
- "~10.5 Mt/year combined primary production" (aluminum) ‚Üí 10500000
- "40,000-60,000 tons/year" (antimony) ‚Üí 50000  
- "~100 tons/year" (rare earth) ‚Üí 100
- "<100 tons/year" ‚Üí 100

Extract the tonnage number:
"""

    try:
        message = client.messages.create(
            model="claude-3-haiku-20240307",  # Fast, cheap model for this task
            max_tokens=50,
            messages=[{"role": "user", "content": prompt}]
        )
        
        result = message.content[0].text.strip()
        
        # Extract just the number from Claude's response
        numbers = re.findall(r'[\d,]+\.?\d*', result)
        if numbers:
            return numbers[0].replace(',', '')
        
    except Exception as e:
        print(f"LLM extraction failed for {metal_name}: {e}")
    
    # Fallback to basic extraction
    return extract_basic_volume(text)

def extract_basic_volume(text):
    """Fallback basic volume extraction."""
    if not text:
        return ''
    
    # Handle ranges like "40-60" -> take midpoint
    range_match = re.search(r'(\d+)-(\d+)', text)
    if range_match:
        start, end = int(range_match.group(1)), int(range_match.group(2))
        return str((start + end) // 2)
    
    # Look for just numbers
    numbers = re.findall(r'[\d,]+\.?\d*', text)
    if numbers:
        return numbers[0].replace(',', '')
    
    return ''

def process_detailed_reports_smart(reports_dir, client):
    """Process all detailed reports with smart LLM extraction."""
    all_summaries = {}
    
    report_files = glob.glob(os.path.join(reports_dir, "*_report.md"))
    
    for report_file in report_files:
        filename = os.path.basename(report_file)
        metal_name = filename.replace('_report.md', '').capitalize()
        
        # Handle special cases
        if metal_name.lower() == 'phosphates':
            metal_name = 'Phosphates'
        elif metal_name.lower() == 'fluorspar':
            metal_name = 'Fluorspar'
        
        try:
            with open(report_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            summaries = extract_italicized_summaries(content)
            
            # For volume sections, use smart extraction
            volume_sections = [
                'US and Allies Domestic Current Production (tons)',
                'US and Allies Domestic Demand 2030 (tons)', 
                'US and Allies Domestic Supply 2030 (tons)'
            ]
            
            for section in volume_sections:
                if section in summaries:
                    original_text = summaries[section]
                    smart_number = smart_extract_volume_with_llm(
                        original_text, metal_name, section, client
                    )
                    summaries[f"{section}_SMART"] = smart_number
                    print(f"{metal_name} {section}: '{original_text}' ‚Üí {smart_number}")
            
            all_summaries[metal_name] = summaries
            print(f"‚úì Processed {metal_name}: {len(summaries)} summaries")
            
        except Exception as e:
            print(f"Error processing {report_file}: {e}")
    
    return all_summaries

def create_smart_improved_csv(existing_data, summaries, output_path, client):
    """Create improved CSV with smart LLM-extracted volumes."""
    
    section_mapping = {
        'Key Bottleneck technology for US and Allies Domestic Production': 'Bottleneck',
        'US and Allies Domestic Current Production (tons)': 'Current Production (tons)',
        'US and Allies Domestic Demand 2030 (tons)': 'Demand 2030 (tons)', 
        'US and Allies Domestic Supply 2030 (tons)': 'Supply 2030 (tons)',
        'Key Discovery Technologies': 'Key Discovery Technologies',
        'Key Extraction Technologies': 'Key Extraction Technologies',
        'Key Separation Technologies': 'Key Separation Technologies', 
        'Key Purification & Refinement Technologies': 'Key Purification & Refinement Technologies',
        'Key Remediation Technologies': 'Key Remediation Technologies'
    }
    
    volume_columns = ['Current Production (tons)', 'Demand 2030 (tons)', 'Supply 2030 (tons)']
    fieldnames = list(next(iter(existing_data.values())).keys())
    
    with open(output_path, 'w', newline='', encoding='utf-8') as f:
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        
        for metal, row_data in existing_data.items():
            new_row = row_data.copy()
            metal_summaries = summaries.get(metal, {})
            updates_made = 0
            
            for markdown_section, csv_column in section_mapping.items():
                if csv_column in new_row:
                    # For volume columns, use smart extracted numbers
                    if csv_column in volume_columns:
                        smart_key = f"{markdown_section}_SMART"
                        if smart_key in metal_summaries:
                            new_row[csv_column] = metal_summaries[smart_key]
                            updates_made += 1
                            continue
                    
                    # For other columns, use regular summaries
                    summary = metal_summaries.get(markdown_section, '')
                    if not summary:
                        for report_section, report_summary in metal_summaries.items():
                            if markdown_section.lower() in report_section.lower():
                                summary = report_summary
                                break
                    
                    if summary:
                        new_row[csv_column] = summary
                        updates_made += 1
            
            writer.writerow(new_row)
            print(f"Updated {metal}: {updates_made} columns")

def load_existing_csv(csv_path):
    """Load existing CSV data."""
    data = {}
    with open(csv_path, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            metal = row['Metal'].strip().title()
            data[metal] = row
    return data

def main():
    """Main function with smart LLM extraction."""
    
    if not HAS_ANTHROPIC:
        print("Error: anthropic package required. Install with: pip install anthropic")
        print("Then set ANTHROPIC_API_KEY environment variable")
        return
    
    # Initialize Claude client
    api_key = os.getenv('ANTHROPIC_API_KEY')
    if not api_key:
        print("Error: Please set ANTHROPIC_API_KEY environment variable")
        print("Get your API key from: https://console.anthropic.com/")
        return
    
    client = anthropic.Anthropic(api_key=api_key)
    
    # Paths
    reports_dir = "detailed_reports"
    input_csv = "static-criticalminerals-2030estimates-GDP.csv"
    output_csv = "enhanced-criticalminerals-2030estimates-GDP.csv"
    
    print("üöÄ Starting Enhanced CSV Creation with Smart LLM Extraction")
    print("="*60)
    print("üìä Using Claude to intelligently extract volume data")
    print("üß† Handling MT ambiguity with contextual analysis")
    print("="*60)
    
    if not os.path.exists(reports_dir):
        print(f"‚ùå Error: Reports directory '{reports_dir}' not found")
        return
    
    if not os.path.exists(input_csv):
        print(f"‚ùå Error: Input CSV '{input_csv}' not found")
        return
    
    # Process with smart extraction
    print("üìã Processing detailed reports with smart LLM volume extraction...")
    summaries = process_detailed_reports_smart(reports_dir, client)
    
    print(f"‚úÖ Found summaries for {len(summaries)} metals")
    
    # Load existing CSV
    print(f"üì• Loading existing data from {input_csv}...")
    existing_data = load_existing_csv(input_csv)
    
    # Create smart improved CSV
    print(f"üîß Creating enhanced CSV: {output_csv}...")
    create_smart_improved_csv(existing_data, summaries, output_csv, client)
    
    print("="*60)
    print(f"üéâ Successfully created {output_csv}")
    print("‚ú® Enhanced CSV with intelligent data extraction complete!")
    print("="*60)

if __name__ == "__main__":
    main()